((3) 0 () 10 ((p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2001-02-08-java\351\200\273\350\276\221\350\277\220\347\256\227\350\265\213\345\200\274\345\277\253\346\215\267\346\226\271\345\274\217.md" . unix) (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2002-01-30-java\345\255\227\347\254\246\344\270\262\346\240\274\345\274\217\345\214\226.md" . unix) (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2015-06-19-take-while-of-clojure.md" . unix) (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2015-06-18-\351\206\252\347\263\237\350\233\213\350\212\261\346\261\244.md" . unix) (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2015-07-03-spyscope\345\256\236\347\216\260\345\216\237\347\220\206.md" . unix) (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2015-06-18-reading-programming-pears.md" . unix) (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2015-06-15-\345\234\250github.io\344\270\212\351\203\250\347\275\262frog\345\215\232\345\256\242\345\274\225\346\223\216.md" . unix) (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2003-03-09-finding-the-intersection-node-of-two-linked-lists.md" . unix) (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2002-03-26-tar-a-file-without-ancestor-directories.md" . unix) (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2002-06-23-sorting-a-binary-search-tree.md" . unix)) () (h ! (equal) ((p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2002-01-30-java\345\255\227\347\254\246\344\270\262\346\240\274\345\274\217\345\214\226.md" . unix) f post (u . "java字符串格式化") (? . 1) 1435693275 (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/blog/2002/01/30/java\345\255\227\347\254\246\344\270\262\346\240\274\345\274\217\345\214\226/index.html" . unix) "/blog/2002/01/30/java字符串格式化/" (u . "2002-01-30T11:23:10") (? . 0) (? . 8) (c (u . "java")) (u . "\n<p><em>java可以使用c语printf风格的字符串格式化指令。</em></p>") #t (u . "\n<p><em>java可以使用c语printf风格的字符串格式化指令。</em></p>\n<!-- more-->\n\n<p>c语printf可以接受多种格式控制符，灵活控制输出格式；java也具备类似机制。</p>\n\n<ol>\n <li>\n  <p>使用java.util.Formatter</p>\n  <p>其构造函可接受一个String，同时提供了一系列format方法。例子：</p>\n  <pre class=\"brush: java\"><code>StringBuffer s = new StringBuffer();\nFormatter f = new Formatter (sb);\nf.format (\"e = %+8.6f\", Math.E);\nSystem.out.println (s);</code></pre>\n  <p>亦可单独使用：</p>\n  <pre class=\"brush: java\"><code>Formatter f = new Formatter ();\nf.format (\"e = %+8.6f\", Math.E);\nSystem.out.println (f);</code></pre>\n  <p>System.out也提供一个format方法：</p>\n  <pre class=\"brush: java\"><code>System.out.format (\"e = %+8.6f\", Math.E);</code></pre></li>\n <li>\n  <p>使用String.format</p>\n  <p>String类直接提供了一个format方法，其封装java.util.Formatter类用于格式化字符串。例子：</p>\n  <pre class=\"brush: java\"><code>String s = String.format (\"e = %+8.6f\", Math.E);\nSystem.out.println (s);</code></pre></li></ol>\n\n<p>控制符详见手册。</p>")) ((p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2001-02-08-java\351\200\273\350\276\221\350\277\220\347\256\227\350\265\213\345\200\274\345\277\253\346\215\267\346\226\271\345\274\217.md" . unix) f post (u . "java逻辑运算赋值快捷方式") (? . 0) 1435682374 (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/blog/2001/02/08/java\351\200\273\350\276\221\350\277\220\347\256\227\350\265\213\345\200\274\345\277\253\346\215\267\346\226\271\345\274\217/index.html" . unix) "/blog/2001/02/08/java逻辑运算赋值快捷方式/" (u . "2001-02-08T02:08:32") #f (? . 1) (c (u . "java")) (u . "\n<p><em>java中不存在<code>&amp;&amp;=</code>，取而代之的是<code>&amp;=</code>。</em></p>") #t (u . "\n<p><em>java中不存在<code>&amp;&amp;=</code>，取而代之的是<code>&amp;=</code>。</em></p>\n<!-- more-->\n\n<div class=\"brush: java\">\n <pre><code>boolean f = true, b = true;\n  ⋮\nf = f &amp;&amp; b;</code></pre></div>\n\n<p>可以写成：</p>\n\n<div class=\"brush: java\">\n <pre><code>boolean f = true, b = true;\n  ⋮\nf &amp;= b;</code></pre></div>\n\n<p>但后者诸位操作，不会进行短路。</p>")) ((p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2003-03-09-finding-the-intersection-node-of-two-linked-lists.md" . unix) f post (u . "finding the intersection node of two linked lists") (? . 7) 1435697560 (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/blog/2003/03/09/finding-the-intersection-node-of-two-linked-lists/index.html" . unix) "/blog/2003/03/09/finding-the-intersection-node-of-two-linked-lists/" (u . "2003-03-09T08:06:51") (? . 9) (? . 6) (c (u . "algorithm") c (u . "算程")) (u . "\n<p><em>finding out the intersection of two linked lists can be solved by this interesting algorithm.</em></p>") #t (u . "\n<p><em>finding out the intersection of two linked lists can be solved by this interesting algorithm.</em></p>\n<!-- more-->\n\n<blockquote>\n <p>there are 2 linked lists, and they may intersect at some node. for example,</p></blockquote>\n\n<p>1 → 2 → 3 → 4 → 5</p>\n\n<p>_____6 ↗</p>\n\n<blockquote>\n <p>list 1 → 2 → 3 → 4 → 5 and 6 → 3 → 4 → 5 have the intersection node 3.</p></blockquote>\n\n<blockquote>\n <p>find out the intersection node if any.</p></blockquote>\n\n<p>here is an $O(n)$ time and $O(1)$ space algorithm. the basic idea is using 2 pointers to traverse the lists. firstly, the 2 pointers point to the heads of the lists respectively. they go through the lists step by step. one case is that the pointers point to the same node before arrive the tails, and that node is the intersection node. one of the other cases is that one pointer arrives a tail while another one not. then, assign the pointer to tail to the head of another list, and continue the process. if the lists intersect, the pointers must encounter at the intersection node. if they do not intersect, the pointers must point to a tail or the tails at some moment.</p>")) ((p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2015-06-18-\351\206\252\347\263\237\350\233\213\350\212\261\346\261\244.md" . unix) f post (u . "醪糟蛋花汤") (? . 3) 1434721082 (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/blog/2015/06/18/\351\206\252\347\263\237\350\233\213\350\212\261\346\261\244/index.html" . unix) "/blog/2015/06/18/醪糟蛋花汤/" (u . "2015-06-18T22:33:36") (? . 5) (? . 2) (c (u . "食谱")) (u . "\n<p><em>醪糟蛋花汤有丰胸、下奶的功效。</em></p>") #t (u . "\n<p><em>醪糟蛋花汤有丰胸、下奶的功效。</em></p>\n<!-- more-->\n\n<p>水煮开，放入三大勺醪糟煮2到3分钟左右，放入适量枸杞，打入鸡蛋花，再煮3到5分钟左右出锅。</p>")) ((p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2015-06-19-take-while-of-clojure.md" . unix) f post (u . "take-while of clojure") (? . 2) 1434723946 (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/blog/2015/06/19/take-while-of-clojure/index.html" . unix) "/blog/2015/06/19/take-while-of-clojure/" (u . "2015-06-19T10:20:23") (? . 3) (? . 4) (c (u . "clojure")) (u . "\n<p>in clojure, <code>take-while' is similar to</code>filter&rsquo;, but they are different.</p>") #t (u . "\n<p>in clojure, <code>take-while' is similar to</code>filter&rsquo;, but they are different.</p>\n<!-- more-->\n\n<div class=\"brush: clojure\">\n <pre><code>&gt; (filter pos? [8 0 -1 2 -3])\n(8 2)\n&gt; (take-while pos? [8 0 -1 2 -3])\n(8)</code></pre></div>\n\n<p>`take-while&rsquo; stops traversing the list when the predicate is false.</p>")) ((p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2015-07-03-spyscope\345\256\236\347\216\260\345\216\237\347\220\206.md" . unix) f post (u . "spyscope实现原理") (? . 4) 1435954622 (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/blog/2015/07/03/spyscope\345\256\236\347\216\260\345\216\237\347\220\206/index.html" . unix) "/blog/2015/07/03/spyscope实现原理/" (u . "2015-07-03T15:42:51") (? . 2) #f (c (u . "clojure") c (u . "spyscope")) (u . "\n<p><em>spyscope把“#spy/p”等符号置于目标符号之前即可工作，其利用了reader的一个特性：edn tagged literal。</em></p>") #t (u . "\n<p><em>spyscope把“#spy/p”等符号置于目标符号之前即可工作，其利用了reader的一个特性：edn tagged literal。</em></p>\n<!-- more-->\n\n<p>以下摘自<a href=\"http://clojure.org/reader\" title=\"clojure's edn tagged elements\">the reader</a>.</p>\n\n<blockquote>\n <p>Tagged literals are Clojure&rsquo;s implementation of edn tagged elements.</p>\n <p>When Clojure starts, it searches for files named data_readers.clj at the root of the classpath. Each such file must contain a Clojure map of symbols, like this:</p>\n <blockquote>\n  <p>{foo/bar my.project.foo/bar</p>\n  <pre><code> foo/baz my.project/baz}</code></pre></blockquote>\n <p>The key in each pair is a tag that will be recognized by the Clojure reader. The value in the pair is the fully-qualified name of a Var which will be invoked by the reader to parse the form following the tag. For example, given the data_readers.clj file above, the Clojure reader would parse this form:</p>\n <blockquote>\n  <h1 id=\"foobar-\">foo/bar [1 2 3]</h1></blockquote>\n <p>by invoking the Var #&rsquo;my.project.foo/bar on the vector [1 2 3]. The data reader function is invoked on the form AFTER it has been read as a normal Clojure data structure by the reader.</p></blockquote>")) ((p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2015-06-18-reading-programming-pears.md" . unix) f post (u . "reading programming pearls") (? . 5) 1434721205 (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/blog/2015/06/18/reading-programming-pearls/index.html" . unix) "/blog/2015/06/18/reading-programming-pearls/" (u . "2015-06-18T20:32:32") (? . 6) (? . 3) (c (u . "programming pearls")) (u . "\n<p><em>this is my note on reading <strong>programming pearls</strong>.</em></p>") #t (u . "\n<p><em>this is my note on reading <strong>programming pearls</strong>.</em></p>\n<!-- more-->\n\n<h2 id=\"column-1-cracking-the-oyster\">column 1 cracking the oyster</h2>\n\n<p>understanding a proglem correctly and comprehensively is critical to solve it.</p>\n\n<h2 id=\"column-2-aha-algorithms\">column 2 aha! algorithms</h2>\n\n<blockquote>\n <p>problem 1: given a sequential file that contains at most four billion 32-bit integers in random order, find a 32-bit integer that isn&rsquo;t in the file (and there must be at least one missing&mdash;why?). how would you solve it if you could use several external main memory? how would you solve it if you could use several external ``scratch&rsquo;&rsquo; files but only a few hundred bytes of main memory?</p></blockquote>\n\n<p>there are $2 ^ 32 = 4294967296 &gt; 4000000000$ 32-bit integers, so there must be ones in the 4 billion integers missing.</p>\n\n<p>if the main memory is ample, the problem can be solved by using <em>bitmap</em> method:</p>\n\n<div class=\"brush: python\">\n <pre><code>def find_missing (a):\n\tr &lt;- nil\n\tk &lt;- make_bitmap ()\n\treset (k) # k is initalized with 0\n\tfor e in a:\n\t\tset (k, e) # bit e is set to 1\n\tfor e in k:\n\t\tif e = 0:\n\t\t   r &lt;- e\n\t\t   break\n\treturn r</code></pre></div>\n\n<p>if the main memory is restricted and spare files are available, <em>binary search</em> may be sued to find a missing number:</p>\n\n<div class=\"brush: python\">\n <pre><code>def find_missing (k, min, max):\n\ta &lt;- load_file (k)\n\tif size (a) = 1:\n\t   return find_missing (a[0])\n\td &lt;- get_file ()\n\tx &lt;- 0\n\tp &lt;- get_file ()\n\ty &lt;- 0\n\tm &lt;- floor ((min + max) / 2)\n\tif is_odd (maximum):\n\t   x &lt;- -1\n\tfor e in a:\n\t\tif e &lt;= m:\n\t\t   x &lt;- x + 1\n\t\t   write_file (d, e)\n\t\telse:\n\t\t   y &lt;- y + 1\n\t\t   write_file (p, e)\n\tif x &lt; y:\n\t   return find_missing (d, min, m)\n\telse: # x may be equal to y: more than 1 number may be missing. if so, choose any part.\n\t   return find_missing (p, m + 1, max)</code></pre></div>\n\n<blockquote>\n <p>problem 2: rotate a one-dimensional vector of $ n $ elements left by $ i $ positions. for instance, with $ n = 8 $ and $ i = 3 $, the vector <em>abcdefgh</em> is rotated to <em>defghabc</em>. try to find a $ O(n) $ time and $O(1)$ space solution.</p></blockquote>\n\n<p>use <em>reverse</em> for the rotating:</p>\n\n<div class=\"brush: python\">\n <pre><code>def rotate (a, i): # a &lt;- [a, b, c, d, e, f, g, h] and i &lt;- 3\n\tn &lt;- size (a)\n\tb &lt;- reverse (a, 0, n - 1) # abcdefgh =&gt; hgfedcba\n\tc &lt;- reverse (b, n - i, n - 1) # hgfedcba =&gt; hgfedabc\n\treturn reverse (c, 0, n - i - 1) # hgfedabc =&gt; defghabc</code></pre></div>\n\n<p>here, <em>reverse</em> can take $ O(n) $ time and $ O(1) $ space:</p>\n\n<div class=\"brush: python\">\n <pre><code>def reverse (a):\n\td &lt;- 0\n\tp &lt;- size (a) - 1\n\twhile d &lt; p:\n\t\t  k &lt;- a[d]\n\t\t  a[d] &lt;- a[p]\n\t\t  a[p] &lt;- k\n\treturn a</code></pre></div>")) ((p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2015-06-15-\345\234\250github.io\344\270\212\351\203\250\347\275\262frog\345\215\232\345\256\242\345\274\225\346\223\216.md" . unix) f post (u . "在github.io上部署frog博客引擎") (? . 6) 1434721082 (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/blog/2015/06/12/\345\234\250github-io\344\270\212\351\203\250\347\275\262frog\345\215\232\345\256\242\345\274\225\346\223\216/index.html" . unix) "/blog/2015/06/12/在github-io上部署frog博客引擎/" (u . "2015-06-12T16:32:08") (? . 7) (? . 5) (c (u . "教程") c (u . "racket") c (u . "frog") c (u . "博客")) (u . "\n<p><em>本文是关于如何在github上部署frog博客引擎的教程。</em></p>") #t (u . "\n<p><em>本文是关于如何在github上部署frog博客引擎的教程。</em></p>\n<!-- more-->\n\n<p><a href=\"http://github.com/greghendershott/frog\">frog</a>是基于<a href=\"http://racket-lang.org/\">racket</a>的博客引擎，本文介绍了如何在<a href=\"http://help.github.com/articles/user-organization-and-project-pages/\">github.io</a>上部署该博客引擎。</p>\n\n<ol>\n <li>\n  <p>制作用于访问github的ssh密钥</p>\n  <p>参考：<a href=\"http://help.github.com/articles/generating-ssh-keys/\">配置github密钥</a>。</p>\n  <ol>\n   <li>\n    <p>查看.ssh已有密钥</p>\n    <pre class=\"brush: bash\"><code>$ ls -al ~/.ssh</code></pre>\n    <p>若使用已有密钥，则忽略下一步。</p></li>\n   <li>\n    <p>制作新ssh密钥</p>\n    <pre class=\"brush: bash\"><code>$ ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\nEnter file in which to save the key (/Users/you/.ssh/id_rsa): [press enter]\nEnter passphrase (empty for no passphrase): [type a passphrase]\n# Enter same passphrase again: [type passphrase again]</code></pre></li>\n   <li>\n    <p>检测ssh-agent是否运行</p>\n    <pre class=\"brush: bash\"><code>$ eval \"$(ssh-agent -s)\"\n# Agent pid 59566</code></pre></li>\n   <li>\n    <p>公钥交由ssh-agent</p>\n    <pre class=\"brush: bash\"><code>$ ssh-add ~/.ssh/id_rsa</code></pre></li>\n   <li>\n    <p>复制公钥到剪贴板</p>\n    <pre class=\"brush: bash\"><code>$ xclip -sel clip &lt; ~/.ssh/id_rsa.pub</code></pre></li>\n   <li>\n    <p>公钥交由github</p>\n    <p>settings &gt; add ssh key</p></li>\n   <li>\n    <p>测试</p>\n    <pre class=\"brush: bash\"><code>$ ssh -T git@github.com</code></pre></li></ol></li>\n <li>\n  <p>设置github用户页</p>\n  <p>参考：<a href=\"http://www.thinkful.com/learn/a-guide-to-using-github-pages/\">github主页指南</a>。</p>\n  <p>要使用username.github.io的域名，则需要创建github用户页作业，作业仓库名必须是：username.github.io。</p></li>\n <li>\n  <p>创建frog作业</p>\n  <p>参考：<a href=\"http://github.com/greghendershott/frog\">frog指南</a>。</p>\n  <ol>\n   <li>\n    <p>克隆github用户页作业</p>\n    <p><code>bash\n $ mkdir frog\n $ cd frog\n $ git clone https://github.com/username/username.github.io.git</code></p></li>\n   <li>\n    <p>安装frog</p>\n    <pre class=\"brush: bash\"><code>$ raco pkg install frog\n$ raco pkg update --update-deps frog\n$ aptitude install python-pygments\n$ aptitude install python3-pygments</code></pre></li>\n   <li>\n    <p>建立作业</p>\n    <pre class=\"brush: bash\"><code>$ cd username.github.io\n$ raco frog --init</code></pre></li></ol></li>\n <li>\n  <p>发布文章</p>\n  <p>参考：<a href=\"http://github.com/greghendershott/frog\">frog指南</a>。</p>\n  <ol>\n   <li>\n    <p>创建文章</p>\n    <pre class=\"brush: bash\"><code>$ raco frog -n \"My Post Title\"</code></pre></li>\n   <li>\n    <p>编译并预览</p>\n    <pre class=\"brush: bash\"><code>$ raco frog -bp</code></pre></li>\n   <li>\n    <p>部署至github</p>\n    <pre class=\"brush: bash\"><code>$ raco frog -b\n$ git add .\n$ git commit -m 'post my blog'\n$ git push origin master</code></pre></li></ol></li></ol>")) ((p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2002-03-26-tar-a-file-without-ancestor-directories.md" . unix) f post (u . "tar a file without ancestor directories") (? . 8) 1435352226 (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/blog/2002/03/26/tar-a-file-without-ancestor-directories/index.html" . unix) "/blog/2002/03/26/tar-a-file-without-ancestor-directories/" (u . "2002-03-26T16:51:15") (? . 1) (? . 9) (c (u . "bash") c (u . "command")) (u . "\n<p><code>tar</code> command may generate a file with unnecessary ancestor directories. use <code>C</code> option to remain the file only:</p>\n\n<div class=\"brush: bash\">\n <pre><code>$ tar -czf xi.tar.gz -C /one/two/three/xi .</code></pre></div>") #f (u . "\n<p><code>tar</code> command may generate a file with unnecessary ancestor directories. use <code>C</code> option to remain the file only:</p>\n\n<div class=\"brush: bash\">\n <pre><code>$ tar -czf xi.tar.gz -C /one/two/three/xi .</code></pre></div>")) ((p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/_src/posts/2002-06-23-sorting-a-binary-search-tree.md" . unix) f post (u . "sorting a binary search tree") (? . 9) 1435097656 (p+ #"/Users/danielwu/Desktop/boke/kejia.github.io/blog/2002/06/23/sorting-a-binary-search-tree/index.html" . unix) "/blog/2002/06/23/sorting-a-binary-search-tree/" (u . "2002-06-23T18:10:55") (? . 8) (? . 7) (c (u . "algorithm")) (u . "\n<p>in-order traversal can be used to sort a binary search tree.</p>") #f (u . "\n<p>in-order traversal can be used to sort a binary search tree.</p>"))))